"""Migration manager for generating and executing file-based migrations.

Features:
 - Timestamp-based migration file generation
 - Discovery and application of pending migrations
 - Rollback of the last applied migration
 - History tracking in ``.restack/migrations.json``
"""

from __future__ import annotations

import importlib.util
import json
import re
import sys
from datetime import datetime
from pathlib import Path
from types import ModuleType

from ..models.migration import Migration, MigrationMeta

MIGRATIONS_DIRNAME = "migrations"
HISTORY_DIRNAME = ".restack"
HISTORY_FILENAME = "migrations.json"


class MigrationManager:
    """Manage migration files and apply/rollback operations."""

    def __init__(self, project_dir: Path) -> None:
        self.project_dir = Path(project_dir)
        self.migrations_dir = self.project_dir / MIGRATIONS_DIRNAME
        self.history_file = self.project_dir / HISTORY_DIRNAME / HISTORY_FILENAME
        # Ensure base directories exist
        self.migrations_dir.mkdir(parents=True, exist_ok=True)
        (self.project_dir / HISTORY_DIRNAME).mkdir(parents=True, exist_ok=True)
        # Ensure package init (optional, helps some tooling)
        init_py = self.migrations_dir / "__init__.py"
        if not init_py.exists():
            init_py.write_text("# Auto-generated by restack-gen\n", encoding="utf-8")

    # -------------------- Generation --------------------
    def generate(self, name: str) -> Path:
        """Create a new timestamped migration file and return its path.

        The filename format is: YYYYMMDD_HHMMSS_<snake_name>.py
        The class name is: MYYYYMMDDHHMMSS_<PascalName>
        """

        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        snake = _to_snake(name)
        pascal = _to_pascal(name)
        file_name = f"{ts}_{snake}.py"
        class_name = f"M{ts.replace('_', '')}_{pascal}"
        file_path = self.migrations_dir / file_name

        template = (
            "from pathlib import Path\n"
            "from restack_gen.models.migration import Migration, MigrationMeta\n\n"
            f"class {class_name}(Migration):\n"
            "    def __init__(self) -> None:\n"
            f'        super().__init__(MigrationMeta(id="{ts}_{snake}", name="{name}", created_at="{datetime.now().isoformat()}"))\n\n'
            "    def up(self, project_dir: Path) -> None:\n"
            "        # TODO: Implement forward changes here\n"
            "        pass\n\n"
            "    def down(self, project_dir: Path) -> None:\n"
            "        # TODO: Implement rollback here\n"
            "        pass\n"
        )
        file_path.write_text(template, encoding="utf-8")
        return file_path

    # -------------------- History --------------------
    def _read_history(self) -> dict:
        if not self.history_file.exists():
            return {"applied": []}
        return json.loads(self.history_file.read_text(encoding="utf-8"))

    def _write_history(self, data: dict) -> None:
        self.history_file.write_text(json.dumps(data, indent=2), encoding="utf-8")

    def _record_applied(self, mig: MigrationMeta) -> None:
        data = self._read_history()
        data.setdefault("applied", []).append(
            {"id": mig.id, "name": mig.name, "applied_at": datetime.now().isoformat()}
        )
        self._write_history(data)

    def _remove_last_applied(self) -> None:
        data = self._read_history()
        if data.get("applied"):
            data["applied"].pop()
            self._write_history(data)

    # -------------------- Execution --------------------
    def list_migration_files(self) -> list[Path]:
        return sorted(self.migrations_dir.glob("*.py"))

    def _load_module(self, path: Path) -> ModuleType:
        spec = importlib.util.spec_from_file_location(path.stem, path)
        if spec is None or spec.loader is None:  # pragma: no cover - defensive
            raise RuntimeError(f"Failed to load migration: {path}")
        module = importlib.util.module_from_spec(spec)
        sys.modules[path.stem] = module
        spec.loader.exec_module(module)
        return module

    def _find_migration_class(self, module: ModuleType) -> type[Migration]:
        for obj in module.__dict__.values():
            if isinstance(obj, type) and issubclass(obj, Migration) and obj is not Migration:
                return obj
        raise RuntimeError("No Migration subclass found in module")

    def discover(self) -> list[tuple[str, Path]]:
        """Return list of (id, path) for migration files discovered."""
        results: list[tuple[str, Path]] = []
        for p in self.list_migration_files():
            m = re.match(r"(\d{8}_\d{6})_(.+)\.py$", p.name)
            if m:
                results.append((f"{m.group(1)}_{m.group(2)}", p))
        results.sort(key=lambda t: t[0])
        return results

    def applied_ids(self) -> list[str]:
        return [entry["id"] for entry in self._read_history().get("applied", [])]

    def apply_pending(self) -> list[str]:
        """Apply all pending migrations in order. Returns list of applied IDs."""
        applied: list[str] = []
        already = set(self.applied_ids())
        for mig_id, path in self.discover():
            if mig_id in already:
                continue
            module = self._load_module(path)
            cls = self._find_migration_class(module)
            instance = cls()  # type: ignore[call-arg]
            if not isinstance(instance, Migration):  # pragma: no cover - defensive
                raise TypeError(f"Invalid migration instance in {path}")
            instance.up(self.project_dir)
            self._record_applied(instance.meta)
            applied.append(instance.meta.id)
        return applied

    def rollback_last(self) -> str | None:
        """Rollback the last applied migration. Returns its ID or None if none."""
        data = self._read_history()
        if not data.get("applied"):
            return None
        last = data["applied"][-1]
        mig_id = last["id"]
        # Find file for this id
        for found_id, path in reversed(self.discover()):
            if found_id == mig_id:
                module = self._load_module(path)
                cls = self._find_migration_class(module)
                instance = cls()  # type: ignore[call-arg]
                instance.down(self.project_dir)
                self._remove_last_applied()
                return mig_id
        return None


def _to_snake(name: str) -> str:
    s = re.sub(r"[^A-Za-z0-9]+", "_", name).strip("_")
    # lower camel/Pascal to snake
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return s.lower()


def _to_pascal(name: str) -> str:
    parts = re.split(r"[^A-Za-z0-9]+", name)
    return "".join(p.capitalize() for p in parts if p)
